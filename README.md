> Compare the application logs before and after you exposed it as a Service. Try to open the app several times while the proxy into the Service is running. What do you see in the logs? Does the number of logs increase each time you open the app?

Yes, the number of log entries increases each time I interact with the app. Before exposing the application as a Service, the logs showed no activity because there was no external traffic reaching the application. Once the app is exposed as a Service and accessed through its external endpoint, every time I open or refresh the app in a browser, a new HTTP request is sent to the backend Pod. This results in new log entries being generated by the application for each request, such as `GET /` lines or status codes, confirming that the Service is correctly routing traffic.

> Notice that there are two versions of kubectl get invocation during this tutorial section. The first does not have any option, while the latter has -n option with value set to kube-system. What is the purpose of the -n option and why did the output not list the pods/services that you explicitly created? Hint: Do some reading about Namespace in Kubernetes documentation.

The `-n` option in the kubectl get command specifies the namespace to look in when querying Kubernetes resources. When the command is used without `-n`, it defaults to the `default` namespace, where user-created Pods and Services are typically deployed unless otherwise specified. In contrast, using `-n kube-system` filters the output to show only the resources running in the `kube-system` namespace, which is reserved for internal Kubernetes components such as CoreDNS and the `kube-proxy`. This is why you donâ€™t see your own Pods or Services listed when using `-n kube-system`, they exist in a different namespace.
